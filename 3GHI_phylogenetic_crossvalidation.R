
# Set to the supplementary file directory.
setwd('~/Desktop/Single Mutant DMS/Data/Supplementary files/')

source('Scripts/basic_functions.R')


# Functions.

# Predict the ddF distribution for an interval using rate inferred from the other intervals.
predict_ddF_distr <- function(proteins, dF, noise, intervals, ddF, eta, k, q = c(0, 1), 
                              niter = 250L, show_plot = TRUE, ...) {
  
  # proteins : integer vector
  #   A list of proteins.
  # dF : numeric matrix
  #   Effect of each mutation on each of the `proteins`. Generated by `calc_dF`.
  # noise : numeric matrix
  #   Standard error of the mean for each mutation's effect on each of the `proteins`.
  #   Generated by `calc_noise`.
  # intervals : two-column integer matrix
  #   Intervals across which changes in mutation effects are simulated.
  #   Each row specifies the ancestral and descendant protein for an interval.
  # ddF : numeric matrix
  #   Amount of change in mutation effect. Generated by `calc_ddF`.
  # eta : numeric matrix
  #   Standard error of the mean for the amount of change in mutation effect.
  #   Generated by `calc_eta`.
  # k : integegr
  #   Interval for which prediction is made.
  # q : numeric vector
  #   Cumulative probability boundaries to dividing mutations into subsets.
  #   E.g., c(0, 0.5, 1) divides mutations into two groups and predicts their ddF distribution separately.
  # niter : integer
  #   Number of predicted ddF distribution to simulate.
  # show_plot : bool
  #   If `TRUE`, a plot of observed vs. predicted ddF distribution is generated.
  # ... : optional parameters to `plot`.
  
  # Simulate the ddF distribution.
  simulate_ddF_distr <- function() {
    
    sim_ddF_k <- matrix(NA_real_, length(ddF_k), niter)
    
    anc_dF <- dF[, proteins == intervals[k, 1L]]
    der_dF <- dF[, proteins == intervals[k, 2L]]

    for(iter in 1L:niter) {
      
      # Sampling dF.
      sim_anc_dF <- rep(0, length(ddF_k))
      sim_der_dF <- rnorm(length(ddF_k), 0, 1) * sigma_k * sqrt(d[k])
        
      # Adding measurement noise.
      sim_anc_dF <- sim_anc_dF + rnorm(length(ddF_k), 0, 1) * noise[, proteins == intervals[k, 1L]]
      sim_der_dF <- sim_der_dF + rnorm(length(ddF_k), 0, 1) * noise[, proteins == intervals[k, 2L]]
      
      # Choosing the initial value of dF.
      displacement <- rep(NA_real_, length(ddF_k))
      
      for(i in 1L:length(ddF_k)) {
        
        if(is.na(anc_dF[i]) & is.na(der_dF[i])) next
        
        if(is.na(anc_dF[i])) {
          prot <- 2L
        } else if(is.na(der_dF[i])) {
          prot <- 1L
        } else {
          prot <- sample(c(1L, 2L), 1L)
        }
        
        if(prot == 1L) {
          displacement[i] <- anc_dF[i]
        } else {
          displacement[i] <- -sim_der_dF[i] + der_dF[i]
        }
      }
      
      sim_anc_dF <- sim_anc_dF + displacement
      sim_der_dF <- sim_der_dF + displacement
      
      # Imposing measurement bounds
      sim_anc_dF[sim_anc_dF < L - WT_ACTIVITY] <- L - WT_ACTIVITY
      sim_anc_dF[sim_anc_dF > U - WT_ACTIVITY] <- U - WT_ACTIVITY
      sim_der_dF[sim_der_dF < L - WT_ACTIVITY] <- L - WT_ACTIVITY
      sim_der_dF[sim_der_dF > U - WT_ACTIVITY] <- U - WT_ACTIVITY
      
      # Converting dF to ddF
      sim_ddF_k[, iter] <- sim_der_dF - sim_anc_dF
    }
    
    sim_ddF_k
  }
  
  # Plot the observed and expected ddF distribution and calculated their variance.
  plot_and_summarize <- function(ddF_k, sim_ddF_k, limit, increment, show_plot, ...) {
    
    # Adding noise to prevent numbers from exactly equaling 0, which makes the histogram appear asymmetric.
    ddF_k <- ddF_k + 1e-5 * sample(c(-1, 1), length(ddF_k), TRUE)
    sim_ddF_k <- sim_ddF_k + 1e-5 * matrix(sample(c(-1, 1), length(sim_ddF_k), TRUE), nrow(sim_ddF_k), ncol(sim_ddF_k))
    
    ddF_k[ddF_k > limit] <- limit + increment / 2
    ddF_k[ddF_k < -limit] <- -limit - increment / 2
    sim_ddF_k[sim_ddF_k > limit] <- limit + increment / 2
    sim_ddF_k[sim_ddF_k < -limit] <- -limit - increment / 2
    
    h_obs <- hist(ddF_k, breaks = seq(-(limit + increment), limit + increment, by = increment), plot = FALSE)
    h_obs$counts <- h_obs$counts / sum(h_obs$counts)
    
    # Expected distribution is made symmetric.
    h_exp <- hist(rbind(sim_ddF_k, -sim_ddF_k), breaks = seq(-(limit + increment), limit + increment, by = increment), plot = FALSE)
    h_exp$counts <- h_exp$counts / sum(h_exp$counts)
    
    if(show_plot) {
      plot(h_obs, xlim = c(-(limit + increment), limit + increment), ...)
      
      plot(NULL, xlim = c(-(limit + increment), limit + increment), ...)
      points(h_exp$mids, h_exp$counts, type = 'l', col = 'red', ...)
      points(h_exp$mids, h_exp$counts, col = 'red', ...)
    }
    
    # Observed and predicted Var(ddF).
    c(var(ddF_k, na.rm = TRUE),  var(as.vector(sim_ddF_k), na.rm = TRUE))
  }
  
  # Calculating parameters required for `simulate_ddF_distr`.
  d <- calc_d(intervals)
  nsub <- calc_d(intervals, return_nsub = TRUE)
  sigma_k <- ml_constant_rate(d[-k], ddF[, -k], eta[, -k])
  
  ddF_k <- ddF[, k]
  sim_ddF_k <- simulate_ddF_distr()
  
  res <- do.call(rbind, lapply(2L:length(q), function(i) {
    
    ql <- quantile(sigma_k, q[i - 1L], na.rm = TRUE)
    qu <- quantile(sigma_k, q[i], na.rm = TRUE)
    mutations <- is.finite(ddF_k) & sigma_k >= ql & sigma_k <= qu
    plot_and_summarize(ddF_k[mutations], sim_ddF_k[mutations, ], 1, 0.1, show_plot, ...)
    
  }))
  
  colnames(res) <- c('Observed', 'Predicted')
  res
}

# Among mutations in `mutant_info`, identify those that are accessible from `prot`.
identify_mutations_for_prot <- function(mutant_info, prot) {
  
  site_WTAA <- paste0(mutant_info$SITE, mutant_info$WTAA)
  site_WTAA_prot <- unique(paste0(DP$SITE[DP$PROT %in% prot], DP$WTAA[DP$PROT %in% prot]))
  
  is_in_prot <- site_WTAA %in% site_WTAA_prot
  is_in_prot[mutant_info$WTAA == mutant_info$MTAA] <- FALSE
  is_in_prot
}


# Analyses.

DP <- read.table('dF.txt', stringsAsFactors = FALSE, header = TRUE)
proteins <- c(1L, 10L, 19L, 6L, 7L, 8L, 12L, 4L, 14L)
# proteins <- c(2L, 11L, 20L, 6L, 7L, 9L, 12L, 5L, 14L) # Alt-All
intervals <- cbind(c(1L, 10L, 19L, 6L, 7L, 8L, 10L, 4L), c(10L, 19L, 6L, 7L, 8L, 12L, 4L, 14L))
# intervals <- matrix(c(c(2L, 11L, 20L, 6L, 7L, 9L, 11L, 5L), c(11L, 20L, 6L, 7L, 9L, 12L, 5L, 14L)), nrow = 8L, ncol = 2L) # Alt-All
mutant_info <- multiple_comparison_data_frame(proteins, FALSE, FALSE)[[1L]][, c('SITE', 'WTAA', 'MTAA')]

# Length of each phylogenetic interval.
d <- calc_d(intervals)

# The effects of mutations in each background.
dF <- calc_dF(proteins)
noise <- calc_noise(proteins)

# The amount of change in each mutation's effect across each unit interval and its measurement noise.
ddF <- calc_ddF(intervals, remove_out_of_range = FALSE)
eta <- calc_eta(intervals)

# Mutations with 4 or less data points are excluded from analysis.
# Here mutations always at the lower bound of measurement are still included in analysis.
retain <- apply(ddF, 1L, function(x) if(sum(!is.na(x)) <= 4L) FALSE else TRUE)


# Analyses.

# Observed and expected Var(ddF).

q <- seq(0, 1, by = 0.1)
var_obs <- matrix(NA_real_, nrow(intervals), length(q) - 1L)
var_exp <- matrix(NA_real_, nrow(intervals), length(q) - 1L)

for(k in 1L:nrow(intervals)) {
  
  mutations <- retain & identify_mutations_for_prot(mutant_info, intervals[k, 1L])
  
  res <- predict_ddF_distr(proteins, dF[mutations, ], noise[mutations, ], intervals, ddF[mutations, ], eta[mutations, ],
                           k, q, niter = 500L, show_plot = FALSE)
  
  var_obs[k, ] <- res[, 1L]
  var_exp[k, ] <- res[, 2L]
}


# Plotting expected vs. observed Var(ddF) for each interval.

for(k in 1L:8L) {
  plot(var_exp[k, ], var_obs[k, ], xlim = c(0, 0.26), ylim = c(0, 0.26),
       pch = 16L, cex = 1.75, col = rgb(0, 0, 0, 0.8))
  abline(a = 0, b = 1)
  print(cor(var_exp[k, ], var_obs[k, ], method = 'spearman'))
  l <- lm(var_obs[k, ] ~ var_exp[k, ])$coefficients
  abline(a = l[1L], b = l[2L], lty = 2)
}


# Plotting prediction for a particular interval.

k <- 1L
q <- seq(0, 1, by = 0.1)
mutations <- retain & identify_mutations_for_prot(mutant_info, intervals[k, 1L])
res <- predict_ddF_distr(proteins, dF[mutations, ], noise[mutations, ], intervals, ddF[mutations, ], eta[mutations, ],
                         k, q, niter = 500L, ylim = c(0, 0.6), cex = 1.2)


# Systematic among-interval variation in the rate of change in mutation effect.

# Not including mutations at the lower bound of measurement for this calculation.
ddF <- calc_ddF(intervals)
eta <- calc_eta(intervals)

# Mutations with 4 or less data points are excluded from analysis.
retain <- apply(ddF, 1L, function(x) if(sum(!is.na(x)) <= 4L) FALSE else TRUE)

lambda <- ml_interval_rate(d, ddF[retain, ], eta[retain, ], 25L)
barplot_with_CI(t(lambda), plot_sd = TRUE, ylim = c(0, 2.5))
abline(h = 1)

# write.table(lambda, 'figure_3/interval_specific_rate.txt')
